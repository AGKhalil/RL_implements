/home/user/miniconda/envs/py36/lib/python3.6/site-packages/gym/logger.py:30: UserWarning: [33mWARN: Box bound precision lowered by casting to float32[0m
  warnings.warn(colorize('%s: %s'%('WARN', msg % args), 'yellow'))
  0%|                                                                      | 0/30000 [00:00<?, ?it/s]/home/user/miniconda/envs/py36/lib/python3.6/site-packages/torch/nn/modules/loss.py:431: UserWarning: Using a target size (torch.Size([999, 1, 1])) that is different to the input size (torch.Size([999, 1])). This will likely lead to incorrect results due to broadcasting. Please ensure they have the same size.
  return F.mse_loss(input, target, reduction=self.reduction)
  0%|                                                                      | 0/30000 [00:00<?, ?it/s]
Traceback (most recent call last):
  File "main_icm_vpg.py", line 125, in <module>
    loss = torch.stack(loss)
RuntimeError: stack expects a non-empty TensorList
>>> loss_for = loss_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squ eeze(0)0[K)
>>> loss_for = loss_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeeeze(0))[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Closs_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squee[1Pze(0))[A[C[C[C[C[C[C[Closs_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeez[1Pe(0))[A[C[C[C[C[C[C[Closs_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeeze[1P(0))[A[C[C[C[C[C[C[Closs_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeeze([1P0))[A[C[C[C[C[C[C[Closs_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeeze(0[1P))[A[C[C[C[C[C[C[Closs_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeeze(0)[C[K[A[C[C[C[C[C[C[Closs_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeeze(0))[K[A[C[C[C[C[C[C[Closs_for_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeeze(0)) [K[A[C[C[C[C[C[C[C[1P
[K[A[C[C[C[C[C[C[1P[1P
tensor(0.0249, grad_fn=<MeanBackward0>)
>>> loss_inv_fun(torch.Tensor(acts).squeeze(0), torch.stack(act_hats).squeeze(0))
tensor(0.9850, grad_fn=<MeanBackward0>)
>>> loss_inv_fun(torch.Tensor(acts).squeeze(0), torch.stack(act_hats).squeeze(0))[C[C[C[C[C[C[C[C[Cfor_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeeze(0))[K.sha pe)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C., torch.stack(next_obs_lat_hats).squeeze(0).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cs, torch.stack(next_obs_lat_hats).squeeze(0).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ch, torch.stack(next_obs_lat_hats).squeeze(0).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ca, torch.stack(next_obs_lat_hats).squeeze(0).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cp, torch.stack(next_obs_lat_hats).squeeze(0).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ce, torch.stack(next_obs_lat_hats).squeeze(0).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C(, torch.stack(next_obs_lat_hats).squeeze(0).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C), torch.stack(next_obs_lat_hats).squeeze(0).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C, torch.stack(next_obs_lat_hats).squeeze([1P0).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C, torch.stack(next_obs_lat_hats).squeeze(0[1P).shape)[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0)[1P.shape)[A[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).[1Pshape)[A[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).s[1Phape)[A[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).sh[1Pape)[A[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).sha[1Ppe)[A[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).shap[1Pe)[A[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).shape[1P)[A[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).shape)[K[A[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).shape) [K[A[C[C[C[C[C[C[C[C[1P
[K[A[C[C[C[C[C[C[C[1P[1P[1P[1@p[1@r[1@intorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).shape) [A[C[C[C[C[C[C[C[Ctorch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).shape))[A[C[C[C[C[C[C[C[C(torch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).shape)[A[C[C[C[C[C[C[C[C

torch.Size([999, 1, 128]) torch.Size([999, 1, 128])
>>> print(torch.stack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).shapee)[A[C[C[20Ploss_inv_fun(torch.Tensor(acts).squeeze(0), torch.stack(act_hats).squeeze(0))
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C.)s)h)a)p)e)[C[C[1@.[1@s[1@h[1@a[1@p[1@e[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1P[1@p[1@r[1@i[1@n[1@t
torch.Size([999, 1]) torch.Size([999, 1, 1])
>>> print(torch.Tensor(acts).squeeze(0).shape, torch.stack(act_hats).squeeze(0).shape)[C[C[C[C[C[C[C[C[C[C[Kacts[K_hats.shape
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'list' object has no attribute 'shape'
>>> act_hats.shapetact_hats.shape[C[C[C[C[Coact_hats.shape[C[C[C[C[C[Cract_hats.shape[C[C[C[C[C[C[Ccact_hats.shape[C[C[C[C[C[C[C[Chact_hats.shape[C[C[C[C[C[C[C[C[C.act_hats.shape[C[C[C[C[C[C[C[C[C[Ctact_hats.shape[C[C[C[C[C[C[C[C[C[C[Ceact_hats.shape[C[C[C[C[C[C[C[C[C[C[C[Cnact_hats.shapesact_hats.shapeoact_hats.shaperact_hats.shape(act_hats.shape[C[C[C[C[C[C[C[C).shape
torch.Size([999])
>>> torch.tensor(act_hats).shape[C[C[C[C[C).shape[C[C[C[C[Ctorch.tensor(act_hats)).shape[C[C[C[C[Cotorch.tensor(act_hats)).shape[C[C[C[C[C[Crtorch.tensor(act_hats)).shape[C[C[C[C[C[C[Cctorch.tensor(act_hats)).shape[C[C[C[C[C[C[C[Chtorch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C.torch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[Cstorch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[C[Ctorch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[C[Catorch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[C[C[Cctorch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[C[C[C[Cktorch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C)torch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1Ptorch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C(torch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: stack(): argument 'tensors' (position 1) must be tuple of Tensors, not Tensor
>>> torch.stack(torch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[13Ptensor(act_hats).shape
torch.Size([999])
>>> torch.tensor(act_hats).shape[1P(act_hats).shape[1P(act_hats).shape[C[C[C[C[C[C[C[C[C[C[C[C[C[C[1P(act_hats).shape[C[C[C[C[C[C[C[C[C[C[C[C[C[1P(act_hats).shape[C[C[C[C[C[C[C[C[C[C[C[C[1P(act_hats).shape[C[C[C[C[C[C[C[C[C[C[C[1P(act_hats).shape[C[C[C[C[C[C[C[C[C[Cs(act_hats).shape[C[C[C[C[C[C[C[C[C[C[Ct(act_hats).shape[C[C[C[C[C[C[C[C[C[C[C[Ca(act_hats).shape[C[C[C[C[C[C[C[C[C[C[C[C[Cc(act_hats).shape[C[C[C[C[C[C[C[C[C[C[C[C[C[Ck(act_hats).shape
torch.Size([999, 1, 1])
>>> torch.stack(act_hats).shape[C[C[C[C[C[C[C[C[C[Ctensor(act_hats).shape[C[C[C[C[C[C[C[C[C[Cstack(torch.tensor(act_hats)).shape[C[C[C[C[C[C[C[C[C[C[13Ptensor(act_hats).shape[C[C[C[C[14Pact_hats.shape[C[C[C[Cprint(torch.Tensor(acts).squeeze(0).shape, torch.stack(act_hats).squeeze(0).shape)[C[C[C[Cact_hats.shape[K[C[C[C[Ctorch.tensor(act_hats).shape[C[C[C[C[14Pact_hats.shape[C[C[C[Cprint(torch.Tensor(acts).squeeze(0).shape, torch.stack(act_hats).squeeze(0).shape)[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cstack(next_obs_lats).squeeze(0).shape, torch.stack(next_obs_lat_hats).squeeze(0).shapee)[A[C[C[20Ploss_inv_fun(torch.Tensor(acts).squeeze(0), torch.stack(act_hats).squeeze(0))
[K[A[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cfor_fun(torch.stack(next_obs_lats).squeeze(0), torch.stack(next_obs_lat_hats).squeeze(0))[C[C[C[C[C[C[C[C[C[17Pinv_fun(torch.Tensor(acts).squeeze(0), torch.stack(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))t(act_hats).squeeze(0))o(act_hats).squeeze(0))r(act_hats).squeeze(0))c(act_hats).squeeze(0))h(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))T(act_hats).squeeze(0))e(act_hats).squeeze(0))s(act_hats).squeeze(0))[1P(act_hats).squeeze(0))n(act_hats).squeeze(0))s(act_hats).squeeze(0))o(act_hats).squeeze(0))r(act_hats).squeeze(0))
/home/user/miniconda/envs/py36/lib/python3.6/site-packages/torch/nn/modules/loss.py:431: UserWarning: Using a target size (torch.Size([999])) that is different to the input size (torch.Size([999, 1])). This will likely lead to incorrect results due to broadcasting. Please ensure they have the same size.
  return F.mse_loss(input, target, reduction=self.reduction)
tensor(0.9850)
>>> loss_inv_fun(torch.Tensor(acts).squeeze(0), torch.Tensor(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))z(act_hats).squeeze(0))t(act_hats).squeeze(0))a(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))[1P(act_hats).squeeze(0))s(act_hats).squeeze(0))t(act_hats).squeeze(0))a(act_hats).squeeze(0))c(act_hats).squeeze(0))k(act_hats).squeeze(0))
tensor(0.9850, grad_fn=<MeanBackward0>)
>>> loss
[]
>>> exit()
